自网道文档https://wangdoc.com/javascript/async/general.html
单线程模型
JavaScript只在一个线程上运行，JavaScript同时只能执行一个任务，其他的任务必须在后面排队等待

JavaScript只在一个线程上运行，不代表JavaScript引擎只有一个线程。事实上JavaScript引擎有多个线程，单个脚本只能在一个线程上运行(称为主线程)
一个主线程其他线程后台配合

js之所以采用单线程是历史原因，从出生开始就是单线程，原因是不想让浏览器变复杂，多线程需要共享资源、且需要对资源使用时进行分配加锁机制
如果一个线程对一个DOM节点修改，另一个也对同一个DOM节点修改那是要以哪个线程为准，必须加线程锁；所以为了避免复杂性，js一开始就是单线程的；这也成了这门语言的核心特征，以后不会改变(资料里这么说的)

这种单线程模式好处就是实现起来比较简单，执行环境相对单纯；

坏处就是只要有一个任务耗时很长，后面的任务都必须排着队等待，这就很难接受了拖延整个程序的执行。
常见的浏览器无响应(假死)，往往就是因为某一段js代码长时间运行(比如死循环),导致整个页面卡死在这个地方，其他任务无法执行。
js本身并不慢(虽然是解释型的但相对后面的速度)，慢的是读写外部数据，比如等待Ajax请求返回结果。这个时候如果对方服务器迟迟没有响应，或者网络不好就会导致脚本长时间停滞

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是通常CPU是闲着的，因为IO操作实在是慢，不得不等结果出来再继续向下执行(不是异步的话)

js的设计者意识到了这个问题，这时CPU完全可以不管IO操作，挂起处于等待中的任务，先运行排在后面的任务。等到IO操作返回结果，再回头把挂起的任务继续执行
这种机制就是JS内部采用的“事件循环”机制(Event Loop)

单线程模型虽然对js造成了限制，但是也是使得它具备了其他语言不具备的优势。
使用得好，js程序是不会出现堵塞的，这就是Node可以用很少的资源，应付大流量访问的原因

为了利用多核CPU的计算能力，HTML5提出的Web Worker标准，允许js脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM.所以这个新标准并没有改变js单线程的本质
这里待续，既然有多个线程，线程间的资源分配肯定是需要注意的

有关异步的串行并行，串并行结合下回再说

下回来了
异步操作的流程控制
如果有多个异步操作，就存在一个流程控制问题  如何确定异步操作执行的顺序，以及如何保证遵守这种顺序

function async(arg, callback){
	console.log('参数为' + arg + ',1秒后返回结果');
	setTimeout(function(){
		callback(arg * 2);
		},1000);
}
这段代码 async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成


